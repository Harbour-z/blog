---
title: XJTUSE编译原理-学习记录
description: 记录我在学习XJTUSE编译原理的一些笔记
publishDate: 2025-09-28 22:40
updatedDate: 2025-10-14 09:30
tags:
  - XJTUSE
  - Compiler
heroImage: {src: './cover.png'}
---

## 课程简介

本课程为西安交大软件学院[徐亦飞老师](https://gr.xjtu.edu.cn/en/web/belonxu_1)教授的2025秋季课程，结合了国防科技大学编译原理课程为基础。

本篇笔记与博客主要为我自己在听课过程中的理解与重点为主，并不是大而全的指南，部分插图为我自己使用[draw.io](https://www.drawio.com/)绘制。

## 第一章 引论

编译中的“递归思想”：

* 递归下降分析
* 基于树遍历的属性计算
* 语法制导翻译

编译的更多应用：shell解释器、SQL、XQuery、HTTP、SAP等。



编译的过程，一般上可以分为：词法分析 -> 语法分析 -> 中间生成（IR） -> 优化 -> 目标代码生成

**词法**

识别与输出token stream，用*有限自动机*描述

**语法**

分解语法单元，用*上下文无关法*描述；

**中间代码**

三元式、四元式、树；

**优化**

依据程序的等价变换规则

**生成目标代码**

任务：将IR转换为特定机器上的目标代码

目标代码有三类：

1. 绝对指令代码：可以直接运行；
2. 可重定位指令代码
3. 汇编指令代码



对于一般的编译器我们可以抽象为下图：

 

以Java语言举个栗子：



## 第二章 高级语言及其语法描述

### 2.1 程序语言的定义

**词法规则**

有限自动机描述

一般：常数、标识符、基本字、算符、界符

**语法规则**

常见语法单位：表达式、语句、分程序、过程、函数、程序等

上下文无关法描述



语义：定义语法单位的意义。

### 2.2 高级语言的一般特性

数据类型三要素：属性、值、操作。

标识符是语法概念，而名字是语义概念

表达式=运算量+算符



左值与右值：

> 左值代表“内存中某个可寻址位置”的表达式，通常是具有名字、生命周期较长的变量或者对象，可以取地址；
>
> 右值：“表示数据本身”的表达式，通常是临时的、无名的结果，不能取地址，使用后即销毁。



### 2.3 程序语言的语法描述

#### 一些概念

有一个**有穷字母表 $\Sigma$ ** 字符集，其中每个元素叫一个**字符**，其中的**字符串**是由其中的字符构成的有穷序列，不包含任何字符的序列称为空字记作 $\varepsilon$ ，该字符集上的全体记作 $\Sigma^*$ (包含空字)

对于字符集V，其自身的n次积记为 $V^n = V V...V$ ，规定$V^0={\varepsilon}$ ；

V的闭包：V中字符组成的所有有限长度的字符串（包括空）构成的集合；即：$V^{*} = V^{0} \cup V^{1} \cup V^{2} \cup V^{3} \cup \dots$

正闭包不包含空字符串。

文法：描述语言的语法结构的形式规则。

#### 上下文无关文法

上下文无关就是：对某个非终结符的重写，与其所处的上下文无关，替换只取决于这个符号本身。

一个上下文无关文法G是一个四元式：$G = (V_T, V_N, S, P)$

* $V_T$：非空终结符集合
* $V_N$：非空非终结符集合，与$V_T$ 交集为空
* S：文法的开始符号，是非终结符
* P：产生式集合（可以理解为非终结符的替换/重写规则）

* S至少必须在某个产生式左部出现一次

**语言**：由某个文法G所生成的所有“合法句子”的集合，通常记作L(G)

**句子**：从其实符号推导出的、仅包含终结符的字符串，是一个完整的程序/表达式

**句型**：从S推导过程中产生的任意中间形式（可能包含非终结符），包括句子本身和中间步骤

> 所有的句子都是句型，但是反之不一定正确。

最左推导和最右推导指的是推导过程中对于哪个位置的非终结符先进行替换。

#### 语法树与二义性(ambiguity)

**语法树**：可以表示一个句型的推导。

**文法的二义性**：如果存在至少一个句子，它有两个不同语法树。

> 可以引申出要判断一个文法是否二义，只需要找到某个句子，它可以构造出两颗以上的不同语法树，这样就是二义的。

如果每个句型最多对应一颗语法树，则：

1. 文法非二义；
2. 使用某种固定推导策略（如最左推导）





## 第三章 词法分析

### 3.3 正规表达式与有限自动机

#### 3.3.1 正规表达式

正规集（Regular Set）：定义在某个字母表上、能被“有限自动机"识别的**语言集合**，也就是可以用正规表达式表示的形式语言。

正规集是通过字母表上的运算递归构造出来的其定义如下：

设 $\Sigma$ 是一个字母表，则在其上定义的**最小的集合族**，满足以下条件的都称为**正规集**：

| 规则                                                         | 解释                   |
| ------------------------------------------------------------ | ---------------------- |
| 1. $\emptyset$ 是正规集                                      | 空集，不包含任何字符串 |
| 2. $\{\epsilon\}$ 是正规集                                   | 只包含空串 $\epsilon$  |
| 3. 对每个 $a \in \Sigma$，集合 $\{a\}$ 是正规集              | 单个字符构成的集合     |
| 4. 若 $A$ 和 $B$ 是正规集，则：  • $A \cup B$ （并）  • $AB$ （连接）  • $A^*$ （Kleene闭包）  都是正规集 | 封闭于三种基本操作     |

> 正规表达式就是正则表达式，只是翻译不同，英文中都是Regular Expression；

不那么正式的定义来说正规集：

1. 它是一类结构简单但实用性强的语言（即字符串集合）
2. 这些语言可以用正则表达式描述，也可以用NFA/DFA实现识别
3. 一个字集合是正规集当且仅当它能用正规式表示

**Kleene定理（Kleene's Theorem）**：每一个正规集都可以用一个正则表达式表示，并且存在一个有限自动机可以识别他；反之亦然

> 所以正规集、正规表达式、有限自动机在概念本质上是等价的

#### 3.3.2 确定有限自动机（DFA）和非确定有限自动机

在谈论DFA前，先看看什么是有限自动机（Finite Automation，FA）。

**有限自动机**是一种抽象的计算模型，用来识别某个字符串是否属于一个“正规集”。有以下特点：

* 只有有限个状态
* 根据输入符号从一个状态转移到另一个状态
* 能判断一个字符串是否被接受（即是否属于该语言）

**确定有限自动机和非确定有限自动机的区别**：

* DFA每个状态对每个输入符号最多只有一个下个状态，NFA一个状态对于同一输入可以跳转到多个状态
* DFA没有空转移，NFA可以通过 ε 不读输入转移到其他状态
* DFA应用于实际编译器中高效匹配Token，NFA是理论建模和正则表达式转换中间步骤
* NFA可以有多个初态，NFA的弧上标记可以是一个字甚至一个正规式，而不一定是单个字符

DFA可以对状态图进行形式化，状态转换图可以表示DFA，在词法分析阶段，DFA是实现正则表达式匹配、识别Token的核心理论工具。

(DFA) M=(S, $\Sigma$, f, $S_0$, F)，分别是：有穷状态机、有穷输入字母表、状态转换函数、唯一初态、终态集（可空）

> 如果终态集为空，那么表达没有任何状态是接受状态，也就是这个DFA不接受任何字符串，即其识别的语言是：
>
> $L(M)=\emptyset$ ，即空语言

DFA M所识别的字的全体记为$L(M)$

\(\varepsilon\) 表示空字符串，DFA 中，若初始状态同时是接受状态（用双圈表示），则该 DFA 能识别空字符串。

关于终态：表示的是在FA完全处理完输入字符串后处于终态，那么该字符串被NFA接受，其本质是一个判定点而非终止点。

**NFA和DFA**

二者描述能力相同，对每个NFA M，都存在一个DFA M‘，使得其所识别字的全体相同。

#### 3.3.3 子集构造法（Subset Construction）

**理解**：对于NFA，其非确定性意味着某个时刻，自动机可能同时处于多个状态，这种多个状态的“状态集合”就是DFA的一个单一状态。也就是说，本质上子集构造法是将NFA的状态子集视为DFA的一个状态，

又称幂集构造，是NFA转化为等价的DFA的标准方法。

1. 预处理——计算$\epsilon$-闭包

对于某个状态集合s，其$\epsilon$-闭包是：从S中每个状态出发，只通过空转移能到达的所有状态的集合（包括自身）

2. 构造初始状态

DFA的初始状态是：$D_0=\epsilon-closure(q_0)$ ，$q_0$是NFA的起始状态

3. 生成新状态（逐个字符扩展）

对当前已知的每个DFA状态，比如集合 $D = \{q_1, q_2, ...\}$：

对 **每一个输入符号 a ∈ Σ**：

* 找出从 D 中每个状态出发、读入 `a` 后能到达的 NFA 状态：

$$
\text{move}(D, a) = \{ p \mid \exists q \in D,\ \delta(q, a) = p \}
$$

* 再把这些状态做 ε-闭包：

$$
D' = \text{ε-closure}(\text{move}(D, a))
$$

* 如果这个新的状态集合 $D'$ 尚未出现在 DFA 中，则将其加入待处理队列。

* 在 DFA 中建立转移：$\delta_{\text{DFA}}(D, a) = D'$

🔁 重复此过程直到没有新的状态产生。

4. 确定哪些是终态

 在*DFA 中，只要某个状态对应的 NFA 状态集合* **包含了至少一个原 NFA 的接受状态**，那么该 DFA 状态就是接受状态。

5. 最小化DFA

使用状态划分法或Hopcroft算法将得到的DFA化简，去掉冗余状态，提高效率。

![image-20251014001602145](./image-20251014001602145.png)

在这个过程中，$\epsilon$-转移的影响已经被”编译”进了DFA的状态设计中，运行时不需要显式的空转移动作。 

## 第四章 语法分析——自上而下分析



## 正则表达式

（正在施工中）

