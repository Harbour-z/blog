---
title: XJTUSE编译原理-学习记录
description: 记录我在学习XJTUSE编译原理的一些笔记
publishDate: 2025-09-28 22:40
updatedDate: 2025-10-14 09:30
tags:
  - XJTUSE
  - Compiler
heroImage: {src: './cover.png'}
---

## 课程简介

本课程为西安交大软件学院[徐亦飞老师](https://gr.xjtu.edu.cn/en/web/belonxu_1)教授的2025秋季课程，结合了国防科技大学编译原理课程为基础。

本篇笔记与博客主要为我自己在听课过程中的理解与重点为主，并不是大而全的指南，部分插图为我自己使用[draw.io](https://www.drawio.com/)绘制。

## 第一章 引论

编译中的“递归思想”：

* 递归下降分析
* 基于树遍历的属性计算
* 语法制导翻译

编译的更多应用：shell解释器、SQL、XQuery、HTTP、SAP等。



编译的过程，一般上可以分为：词法分析 -> 语法分析 -> 中间生成（IR） -> 优化 -> 目标代码生成

**词法**

识别与输出token stream，用*有限自动机*描述

**语法**

分解语法单元，用*上下文无关法*描述；

**中间代码**

三元式、四元式、树；

**优化**

依据程序的等价变换规则

**生成目标代码**

任务：将IR转换为特定机器上的目标代码

目标代码有三类：

1. 绝对指令代码：可以直接运行；
2. 可重定位指令代码
3. 汇编指令代码



对于一般的编译器我们可以抽象为下图：

 

以Java语言举个栗子：



## 第二章 高级语言及其语法描述

### 2.1 程序语言的定义

**词法规则**

有限自动机描述

一般：常数、标识符、基本字、算符、界符

**语法规则**

常见语法单位：表达式、语句、分程序、过程、函数、程序等

上下文无关法描述



语义：定义语法单位的意义。

### 2.2 高级语言的一般特性

数据类型三要素：属性、值、操作。

标识符是语法概念，而名字是语义概念

表达式=运算量+算符



左值与右值：

> 左值代表“内存中某个可寻址位置”的表达式，通常是具有名字、生命周期较长的变量或者对象，可以取地址；
>
> 右值：“表示数据本身”的表达式，通常是临时的、无名的结果，不能取地址，使用后即销毁。



### 2.3 程序语言的语法描述

#### 一些概念

有一个**有穷字母表 $\Sigma$ ** 字符集，其中每个元素叫一个**字符**，其中的**字符串**是由其中的字符构成的有穷序列，不包含任何字符的序列称为空字记作 $\varepsilon$ ，该字符集上的全体记作 $\Sigma^*$ (包含空字)

对于字符集V，其自身的n次积记为 $V^n = V V...V$ ，规定$V^0={\varepsilon}$ ；

V的闭包：V中字符组成的所有有限长度的字符串（包括空）构成的集合；即：$V^{*} = V^{0} \cup V^{1} \cup V^{2} \cup V^{3} \cup \dots$

正闭包不包含空字符串。

文法：描述语言的语法结构的形式规则。

#### 上下文无关文法

上下文无关就是：对某个非终结符的重写，与其所处的上下文无关，替换只取决于这个符号本身。

一个上下文无关文法G是一个四元式：$G = (V_T, V_N, S, P)$

* $V_T$：非空终结符集合
* $V_N$：非空非终结符集合，与$V_T$ 交集为空
* S：文法的开始符号，是非终结符
* P：产生式集合（可以理解为非终结符的替换/重写规则）

* S至少必须在某个产生式左部出现一次

**语言**：由某个文法G所生成的所有“合法句子”的集合，通常记作L(G)

**句子**：从其实符号推导出的、仅包含终结符的字符串，是一个完整的程序/表达式

**句型**：从S推导过程中产生的任意中间形式（可能包含非终结符），包括句子本身和中间步骤

> 所有的句子都是句型，但是反之不一定正确。

最左推导和最右推导指的是推导过程中对于哪个位置的非终结符先进行替换。

#### 语法树与二义性(ambiguity)

**语法树**：可以表示一个句型的推导。

**文法的二义性**：如果存在至少一个句子，它有两个不同语法树。

> 可以引申出要判断一个文法是否二义，只需要找到某个句子，它可以构造出两颗以上的不同语法树，这样就是二义的。

如果每个句型最多对应一颗语法树，则：

1. 文法非二义；
2. 使用某种固定推导策略（如最左推导）





## 第三章 词法分析

### 3.3 正规表达式与有限自动机

#### 3.3.1 正规表达式

正规集（Regular Set）：定义在某个字母表上、能被“有限自动机"识别的**语言集合**，也就是可以用正规表达式表示的形式语言。

正规集是通过字母表上的运算递归构造出来的其定义如下：

设 $\Sigma$ 是一个字母表，则在其上定义的**最小的集合族**，满足以下条件的都称为**正规集**：

| 规则                                                         | 解释                   |
| ------------------------------------------------------------ | ---------------------- |
| 1. $\emptyset$ 是正规集                                      | 空集，不包含任何字符串 |
| 2. $\{\epsilon\}$ 是正规集                                   | 只包含空串 $\epsilon$  |
| 3. 对每个 $a \in \Sigma$，集合 $\{a\}$ 是正规集              | 单个字符构成的集合     |
| 4. 若 $A$ 和 $B$ 是正规集，则：  • $A \cup B$ （并）  • $AB$ （连接）  • $A^*$ （Kleene闭包）  都是正规集 | 封闭于三种基本操作     |

> 正规表达式就是正则表达式，只是翻译不同，英文中都是Regular Expression；

不那么正式的定义来说正规集：

1. 它是一类结构简单但实用性强的语言（即字符串集合）
2. 这些语言可以用正则表达式描述，也可以用NFA/DFA实现识别
3. 一个字集合是正规集当且仅当它能用正规式表示

**Kleene定理（Kleene's Theorem）**：每一个正规集都可以用一个正则表达式表示，并且存在一个有限自动机可以识别他；反之亦然

> 所以正规集、正规表达式、有限自动机在概念本质上是等价的

#### 3.3.2 确定有限自动机（DFA）和非确定有限自动机

在谈论DFA前，先看看什么是有限自动机（Finite Automation，FA）。

**有限自动机**是一种抽象的计算模型，用来识别某个字符串是否属于一个“正规集”。有以下特点：

* 只有有限个状态
* 根据输入符号从一个状态转移到另一个状态
* 能判断一个字符串是否被接受（即是否属于该语言）

**确定有限自动机和非确定有限自动机的区别**：

* DFA每个状态对每个输入符号最多只有一个下个状态，NFA一个状态对于同一输入可以跳转到多个状态
* DFA没有空转移，NFA可以通过 ε 不读输入转移到其他状态
* DFA应用于实际编译器中高效匹配Token，NFA是理论建模和正则表达式转换中间步骤
* NFA可以有多个初态，NFA的弧上标记可以是一个字甚至一个正规式，而不一定是单个字符

DFA可以对状态图进行形式化，状态转换图可以表示DFA，在词法分析阶段，DFA是实现正则表达式匹配、识别Token的核心理论工具。

(DFA) M=(S, $\Sigma$, f, $S_0$, F)，分别是：有穷状态机、有穷输入字母表、状态转换函数、唯一初态、终态集（可空）

> 如果终态集为空，那么表达没有任何状态是接受状态，也就是这个DFA不接受任何字符串，即其识别的语言是：
>
> $L(M)=\emptyset$ ，即空语言

DFA M所识别的字的全体记为$L(M)$

\(\varepsilon\) 表示空字符串，DFA 中，若初始状态同时是接受状态（用双圈表示），则该 DFA 能识别空字符串。

关于终态：表示的是在FA完全处理完输入字符串后处于终态，那么该字符串被NFA接受，其本质是一个判定点而非终止点。

**NFA和DFA**

二者描述能力相同，对每个NFA M，都存在一个DFA M‘，使得其所识别字的全体相同。

#### 3.3.3 子集构造法（Subset Construction）

**理解**：对于NFA，其非确定性意味着某个时刻，自动机可能同时处于多个状态，这种多个状态的“状态集合”就是DFA的一个单一状态。也就是说，本质上子集构造法是将NFA的状态子集视为DFA的一个状态，

又称幂集构造，是NFA转化为等价的DFA的标准方法。

1. 预处理——计算$\epsilon$-闭包

对于某个状态集合s，其$\epsilon$-闭包是：从S中每个状态出发，只通过空转移能到达的所有状态的集合（包括自身）

2. 构造初始状态

DFA的初始状态是：$D_0=\epsilon-closure(q_0)$ ，$q_0$是NFA的起始状态

3. 生成新状态（逐个字符扩展）

对当前已知的每个DFA状态，比如集合 $D = \{q_1, q_2, ...\}$：

对 **每一个输入符号 a ∈ Σ**：

* 找出从 D 中每个状态出发、读入 `a` 后能到达的 NFA 状态：

$$
\text{move}(D, a) = \{ p \mid \exists q \in D,\ \delta(q, a) = p \}
$$

* 再把这些状态做 ε-闭包：

$$
D' = \text{ε-closure}(\text{move}(D, a))
$$

* 如果这个新的状态集合 $D'$ 尚未出现在 DFA 中，则将其加入待处理队列。

* 在 DFA 中建立转移：$\delta_{\text{DFA}}(D, a) = D'$

🔁 重复此过程直到没有新的状态产生。

4. 确定哪些是终态

 在*DFA 中，只要某个状态对应的 NFA 状态集合* **包含了至少一个原 NFA 的接受状态**，那么该 DFA 状态就是接受状态。

5. 最小化DFA

使用状态划分法或Hopcroft算法将得到的DFA化简，去掉冗余状态，提高效率。

![image-20251014001602145](./image-20251014001602145.png)

在这个过程中，$\epsilon$-转移的影响已经被”编译”进了DFA的状态设计中，运行时不需要显式的空转移动作。 

## 第四章 语法分析——自上而下分析

在语法分析阶段使用CFG描述语法规则，其表达能力足够强大而又足够简单，可以构造有效的分析算法来检验一个给定字符串是否由某个上下文无关文法产生。

词法分析采用正规式和有限自动机即可表达词法规则。

<img src="./image-20251030175808439.png" alt="image-20251030175808439" style="zoom: 33%;" />

**自上而下分析**

从文法的开始符号出发，通过推导构建语法树或寻找最左推导序列，以验证输入结构的合法性。

### 4.1 基本概念

**语言（Language）**：给定文法G，所有能从开始符号S推导出的终结符串的集合，记作L（G）；

**句型（Sentential Form）**：从文法开始符号S出发，经过任意步推导（包括0步）得到的符号串（可以包含终结符和非终结符）；

**句子（Sentence）**：只由终结符组成；

**短语**：在某个句型中，可以被某条文法规则整体替换掉的一段字串；也就是句型中某个非终结符通过若干步推导得到的子串，可以是间接的。

* 即这个子串是“合法地从某个非终结符生长出来的”，无论用了几步

**直接短语（Immediate Constituent / Direct Phrase）**：在某个句型的语法树中，如果某个非终结符A通过一步推导**直接推导**出一个子串B，即存在产生式A->B，则B是该句型的一个直接短语

> 一个句型可能有多个直接短语

**句柄（Handle）**：最左边的直接短语，是自下而上规约时的“第一个下手目标”

> 自底向上分析器（如LR（1））的工作方式就是不断在输入串中寻找句柄，然后用对应的产生式左部规约它。

**找短语的方法**：逆向思考，哪些字串曾经是一个非终结符（非终结符本身就是短语）

**最左/右推导**：每一步推导中，总是选择最左/右边的非终结符进行替换。引申出最（）句型的概念，即在最（）推导中产生的任意中间句型

### 4.2 自上而下带来的问题

这里实际是带回溯的递归下降分析的问题。另一种不带回溯的递归下降分析属于LL（1）的一种具体实现

即回溯采用穷尽一切可能的试探法，效率很低；含有左递归的文法会导致无限循环（如 `P → Pα`）

### 4.3 LL（1）分析法

> 这是实际编译器设计中，自上而下分析法最常用的实现

#### 4.3.1 原理

> 需要消除文法的左递归；克服回溯

第一个L：从左到右扫描输入串

第二个L：产生最左推导

文法中每个非终结符A的各个产生式的候选首符集两两不相交

1：每次向前看一个符号

核心思想：通过预测分析表，避免回溯，直接确定下一步应该应用的产生式

**消除左递归**

假如左递归：$P \rightarrow P\alpha| \beta$ ，其中$\beta$ 不以P开头。

可以把P的规则等价改写为：

$P\rightarrow \beta P'$

$P'\rightarrow \alpha P'|\epsilon$

#### 4.3.2 关键概念

**FIRST集合**：

* 对于文法符号X，FIRST(X)是所有可以从X中推导出的首终结符集合
* 如果X可以推出$\epsilon$ ，则其也在FIRST(X)中

<img src="./image-20251031092334584.png" alt="image-20251031092334584" style="zoom:67%;" />

**FOLLOW集合**

* 对非终结符A，FOLLOW(A)是所有紧跟在A后面的终结符集合
* 如果A可以出现在句型末尾，则#（输入结束符）也在FOLLOW(A)中

<img src="./image-20251031092833931.png" alt="image-20251031092833931" style="zoom:67%;" />

**预测分析表**

* 表的行是文法的非终结符
* 列是终结符（包括#）
* 单元格包含产生式，表示的是当处于该非终结符且下一个输入符号是该终结符时应该用的产生式

#### 4.3.3 实现步骤

1. 消除文法中的左递归
2. 提取公共左因子

<img src="./image-20251031092138372.png" alt="image-20251031092138372" style="zoom:33%;" />

1. 计算每个非终结符的FIRST集合
2. 计算每个非终结符的FOLLOW集合
3. 构建预测分析表
4. 使用预测分析表进行语法分析

**分析过程**

1. 初始化：将开始符号S压入分析栈，输入指针指向输入串第一个符号
2. 当栈顶是终结符时：
   - 匹配输入符号则弹出栈顶并移动输入指针
   - 否则报告语法错误
3. 当栈顶是非终结符A时：
   - 查找预测分析表中A行和当前输入符号列对应的产生式（即查表M[A, a]得到应使用的产生式）
   - 如果存在，弹出A，将产生式右部逆序压入栈
   - 如果不存在，报告语法错误
4. 重复步骤2和3，直到栈空或发生错误

#### 4.3.4 FIRST集和FOLLOW集的理解

核心作用：让LL(1)分析器直接能选择当前输入符号该用哪个产生式，无需回溯。

$FIRST(X) = { a | X ⇒* aβ }$

**计算规则**：

1. X为终结符，`FIRST(X)={X}`
2. X->$\epsilon$ 则`FIRST(X)={$\epsilon$}`
3. **若 `X → Y₁Y₂...Yₙ`**，`FIRST(X) = (FIRST(Y₁) - {ε}) ∪ (FIRST(Y₂) - {ε}) ∪ ... ∪ (FIRST(Yₙ) - {ε})`，其中 i 为第一个Yi不为空的，**若所有 `FIRST(Yᵢ) = {ε}`**，则 `FIRST(X) = {ε}`

计算规则最后一条实则是在找第一个能贡献实际首字符的集合。

> 这里减去空串是因为：Y1如果能推出空，则其不贡献首符号，需要看下一个，减去是为了表示对应的Yi能贡献的实际首符号；



FOLLOW(A)集是A后面可能跟着的终结符符号，计算规则：

* **`FOLLOW(S) = {#}`**
* **若 `A → αBβ`**，FOLLOW(B) += FIRST(β) - {ε}
* **若 `A → αB` 或 `A → αBβ` 且 `β ⇒\* ε`**，FOLLOW(B) += FOLLOW(A)

#### 4.3.5 间接左递归消除方法

间接左递归也会导致自顶向下语法分析器陷入无限循环。

**消除的基本思路**：先将间接左递归化为直接左递归，然后应用直接左递归的消除方法。

**消除算法**：

1. 对非终结符排序：将文法中的所有非终结符按某种顺序排列（P₁, P₂, ..., Pₙ）
2. 依次处理每个非终结符：替换间接递归并消除直接左递归
3. 化简文法：删除从开始符号出发永远无法到达的非终结符的产生式

### 4.4 递归下降分析程序构造











## 第五章 语法分析——自下而上分析

### 5.1 自下而上分析的基本问题

**自下而上分析法**

**核心思想**：从输入串开始，逐步将其规约（reduce）为文法的起始符号（通常为$）。从树的末端开始，构造语法树。

关键操作即：移进（shift）和规约（Reduce）

还有两个辅助动作：

* Accept（接受）：当栈中只有开始符号S且输入结束时，分析成功
* Error：无法移进也无法规约时，语法错误

**关键概念**

* 句柄 Handle：某个产生式右部的一个子串，将其替换为对应非终结符，就能得到输入句子最右推导的前一步
* 句柄也叫可规约串（Reducible String），可规约串不一定全是终结符

**常用方法**：

1. 算符优先分析法（Operator Precedence Parsing）
   * 应用于表达式文法（如算数表达式）
   * 利用算符之间的优先级关系来决定
   * 简单快速，但是仅适用于“算符优先文法”
2. LR分析法（Left-to-Right，Rightmost derivation in reverse）
   * 现代编译器广泛使用的技术（如Yacc/Bison工具基于LR）

| 类型                         | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| **LR(0)**                    | 最简单形式，不使用展望符（lookahead），常存在冲突            |
| **SLR(1)**（Simple LR）      | 在 LR(0) 基础上加入 FOLLOW 集来解决部分冲突，能力较弱但仍优于 LL |
| **LR(1)**                    | 完整版，每个项目都带有一个展望符（lookahead terminal），非常精确，但状态爆炸 |
| **LALR(1)**（Look-Ahead LR） | 在 LR(1) 基础上合并等价状态，兼顾能力与效率，Bison 默认生成 LALR(1) 分析器 |



**句柄Handle**的正式定义：在某个规范推导（最右推导）过程中，当前句型中能通过一步反向推导归约，并最终导向起始符号的最左子串，称为该句型的句柄。

> 这里有个我理解的误区，最右推导意味右边先成形，所以在规约时候应该最先还原最左边的那些“后来生成”的部分，因此句柄是最左子串



**规范规约**

定义：n假定a是文法G的一个句子，我们称序列

$\alpha_n,\alpha_{n-1},...,\alpha_{0}$

  是a的一个规范归约，如果此序列满足：

1. an= a
2. a0为文法的开始符号，即a0=S
3. 对任何i，0<=i<=n， ai-1是从ai经把**句柄替换**成为相应产生式左部符号而得到的

> 不难发现，规范规约是最右推到的逆过程。

由规范推导出的句型称为规范句型。

栈是语法分析的基本数据结构，#是栈底符号。

#### 对于PPT中一个示例的解释

<img src="/Users/harbour/programming-code/blog/src/content/blog/XJTUSE-Compiler/assets/image-20251221113441806.png" alt="image-20251221113441806" style="zoom:50%;" />

这里我开始疑惑为什么短语、直接短语和句柄中没有F、T等符号，后来明白：

1. 对于一个句型，其短语、直接短语和句柄，都只能由该句型中实际出现的符号组成，不能包含文法中存在但是句型中没有的符号
2. 所有这些概念都是针对当前句型的子串定义的，它们是句型的子串，不是文法中的任意符号组合



**关于PPT中直接短语的一个通俗解释**：

在语法树里，随便挑一个非终结符（比如 `T`），把它当成小树的根：

- 把它下面所有的**叶子符号**按从左到右顺序连起来，得到一个子串；
- 这个子串就叫做**关于这个非终结符的一个短语**。

特别地：

- 如果这个小树**只有两层**（根直接连到叶子，中间没其他非终结符），
  那么这个短语就是**直接短语**（因为文法中有一条规则直接生成它）。
- 如果小树有**三层或更多**，那就是普通短语（需要多步推导）。



### 5.2 算符优先分析算法

基本思想：起决定作用的是相邻的两个算符（终结符）之间的优先关系。

**算符文法（Operator Precedence Grammar，OPG）**：一个文法，它的**任一产生式**的右部不含两个并列相邻的非终结符（即...QR...这样的推导式右部），则为算符文法。

> 我理解对于非终结符之间必须有作为“符号或运算符”的终结符，以此来形成其规约优先级

**算符优先文法**在此基础上还多了一个约束：

* **优先关系唯一**：任意两个终结符之间，至多存在一种优先关系
* 以上约束的本质是二义性文法，要能够构造无冲突的优先关系表
* 不含$\epsilon$-产生式

**符号优先级的定义**：

1. `a = b` 当且仅当文法G中含有形如P→…ab…或P→…aQb…的产生式；
2. `a < b`当且仅当G中含有形如P→…aR…的产生式， 而R $\Rightarrow^+$ b…或R$\Rightarrow^+$ Qb…
3. `a > b`  当且仅当G中含有形如P→…Rb…的产生式，而 R $\Rightarrow^+$  …a或R  $\Rightarrow^+$ …aQ



FIRSTVT(A) = 从非终结符 A 推导出的串中，第一个可能的终结符的集合；

LASTVT(A) =从非终结符 A 推导出的串中，最后一个可能的终结符的集合

> 需要这两个集合是因为

**构建优先关系表哦步骤**：

1. 列出所有终结符；
2. 计算 FIRSTVT 和 LASTVT；
3. 推导优先级关系（优先级高的先规约）
